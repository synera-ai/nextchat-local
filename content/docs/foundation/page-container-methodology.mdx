---
title: "Page Container Design Methodology"
description: "Core architectural pattern for building consistent, maintainable pages in NextChat"
lastModified: "2025-01-27T18:41:57.733Z"
---

# Page Container Design Methodology

The Page Container Design Methodology is NextChat's proven architectural pattern for building consistent, maintainable, and reusable page structures. This methodology has been successfully implemented in production, achieving 85-97% code reduction while maintaining 100% functionality.

## Overview

The Page Container Design Methodology provides a declarative, configuration-driven approach to building pages with tabs and sections. Instead of hardcoding page structures, you define them through configuration objects that work across different pages and contexts.

### Key Benefits

- **ğŸ¯ Consistency**: Standardized page structure across the application
- **ğŸ”§ Maintainability**: Centralized configuration management
- **â™»ï¸ Reusability**: Generic components handle all page rendering
- **ğŸ“¦ Code Reduction**: 85-97% reduction in main page components
- **ğŸ›¡ï¸ Type Safety**: Full TypeScript support with validation
- **â™¿ Accessibility**: Built-in a11y compliance and keyboard navigation
- **ğŸ”„ Backwards Compatibility**: 100% functionality preservation

## Core Concepts

### 1. Declarative Configuration

Pages are defined through configuration objects rather than hardcoded JSX:

```typescript
// Instead of hardcoding tabs and content
function SettingsPage() {
  const [activeTab, setActiveTab] = useState("general");
  return (
    <div>
      <Tabs>
        <Tab onClick={() => setActiveTab("general")}>General</Tab>
        <Tab onClick={() => setActiveTab("chat")}>Chat</Tab>
      </Tabs>
      {activeTab === "general" && <SettingsGeneral />}
      {activeTab === "chat" && <SettingsChat />}
    </div>
  );
}

// Use declarative configuration
const settingsPageConfig = createPageConfig("settings", "Settings", [
  createTab("general", "General", [
    createSection("general-section", "General Settings", SettingsGeneralWrapper)
  ]),
  createTab("chat", "Chat", [
    createSection("chat-section", "Chat Settings", SettingsChatWrapper)
  ])
]);

function SettingsPage() {
  return <PageContainer config={settingsPageConfig} />;
}
```

### 2. Wrapper Component Pattern

The wrapper pattern bridges existing components to the configuration system without breaking changes:

```typescript
// Wrapper component gathers required props
export function SettingsGeneralWrapper() {
  const config = useAppConfig();
  const updateStore = useUpdateStore();
  const currentVersion = useCurrentVersion();
  const hasNewVersion = useHasNewVersion();
  
  return (
    <SettingsGeneral
      config={config}
      updateConfig={updateStore}
      currentVersion={currentVersion}
      hasNewVersion={hasNewVersion}
    />
  );
}

// Original component remains unchanged
function SettingsGeneral(props: SettingsGeneralProps) {
  // All existing logic preserved
}
```

### 3. Generic Page Container

A single, reusable component handles all page rendering:

```typescript
export function PageContainer({
  config,
  defaultTab,
  onTabChange,
  className,
}: PageContainerProps) {
  return (
    <PageConfigProvider config={config}>
      <div className={`${styles.pageContainer} ${className || ''}`}>
        <PageHeader config={config} />
        <PageContent 
          config={config}
          defaultTab={defaultTab}
          onTabChange={onTabChange}
        />
      </div>
    </PageConfigProvider>
  );
}
```

## Architecture Components

### Configuration System

```typescript
interface PageConfig {
  id: string;                    // Unique identifier
  title: string;                 // Page title
  subtitle?: string;             // Optional page subtitle
  tabs: TabConfig[];            // Array of tab configurations
  layout?: "single" | "multi";  // Layout mode
  metadata?: Record<string, any>; // Custom metadata
}

interface TabConfig {
  id: string;                    // Unique identifier
  label: string;                 // Display label
  sections: PageSection[];      // Array of sections
  badge?: number | string;       // Optional badge
  disabled?: boolean;            // Whether tab is disabled
}

interface PageSection {
  id: string;                    // Unique identifier
  label: string;                 // Display label
  component: React.ComponentType<any>; // React component
  props?: Record<string, any>;   // Props passed to component
}
```

### State Management

```typescript
interface PageContextValue {
  config: PageConfig;                    // Current configuration
  currentTab: string;                   // Currently active tab
  setCurrentTab: (tabId: string) => void; // Function to switch tabs
  currentSection?: string;              // Currently active section
  setCurrentSection?: (sectionId: string) => void;
}
```

### Factory Functions

```typescript
// Create page configuration
const pageConfig = createPageConfig(
  "settings",
  "Settings",
  [
    createTab("general", "General", [
      createSection("general-section", "General Settings", SettingsGeneralWrapper)
    ])
  ],
  {
    subtitle: "Configure your application",
    layout: "multi"
  }
);
```

## Proven Success Stories

### Settings Page Migration

**Before**: 1,579 lines of complex tab management code
**After**: 42 lines using PageContainer
**Reduction**: 97% code reduction
**Result**: All functionality preserved, improved maintainability

### Masks Page Migration

**Before**: 1,000+ lines of hardcoded page structure
**After**: 100+ lines using PageContainer
**Reduction**: 90% code reduction
**Result**: All features preserved, better state management

## Implementation Strategy

### Phase 1: Infrastructure (Complete)
- âœ… Type system and validation
- âœ… Factory functions and utilities
- âœ… Context provider and hooks
- âœ… Generic PageContainer component
- âœ… 19 passing tests

### Phase 2: Migration Pattern (Complete)
- âœ… Wrapper component architecture
- âœ… Settings page migration
- âœ… Masks page migration
- âœ… Integration testing

### Phase 3: Documentation (Current)
- ğŸ”„ Comprehensive documentation
- ğŸ”„ Migration guides
- ğŸ”„ Best practices
- ğŸ”„ Examples and templates

## When to Use Page Container

### âœ… Use Page Container When:
- Building new pages with tabs and sections
- Migrating existing pages for consistency
- Need standardized page structure
- Want to reduce code duplication
- Require centralized state management
- Need accessibility compliance

### âŒ Don't Use Page Container When:
- Simple single-content pages
- Pages with complex, unique layouts
- Pages requiring custom rendering logic
- Prototype or experimental pages

## Getting Started

1. **Understand the Pattern**: Read the [Implementation Guide](/docs/developers/page-container-implementation)
2. **See Examples**: Check the [Examples and Patterns](/docs/components/page-container-examples)
3. **Migrate Existing Pages**: Follow the [Migration Guide](/docs/developers/page-container-migration)
4. **Follow Best Practices**: Review [Best Practices Guide](/docs/developers/page-container-best-practices)

## Related Documentation

- [Implementation Guide](/docs/developers/page-container-implementation) - Detailed implementation steps
- [Migration Guide](/docs/developers/page-container-migration) - Migrating existing pages
- [Best Practices](/docs/developers/page-container-best-practices) - Recommended patterns
- [API Reference](/docs/reference/page-container-api) - Complete API documentation
- [Examples](/docs/components/page-container-examples) - Code examples and patterns

## Next Steps

Ready to implement the Page Container Design Methodology? Start with the [Implementation Guide](/docs/developers/page-container-implementation) for detailed step-by-step instructions.
