# Unified Project Management System Rules

## Core Principles

### 1. Project-First Development
- Every code change must be associated with a project
- All work must be tracked through the project management system
- No standalone changes without project context

### 2. Version-Controlled Planning
- All projects use semantic versioning (v1.0.0, v1.1.0, etc.)
- File naming prioritizes versioning over date-based namespacing
- Plan analysis and version tracking take precedence over chronological organization

### 3. Regular Commit Integration
- Every project phase must include regular commits
- Commit messages must reference project versions and phases
- Automated commit triggers for project milestones

## Project Management Rules

### Project Detection and Context
- **Always** check `./docs/projects/active/` and `./docs/projects/ideas/` before starting work
- Load full project context when working on existing projects
- Create new projects for any significant changes (features, refactoring, documentation)
- Update project documents with every code change

### Project Lifecycle Management
- **Ideas**: Initial concept and research phase
- **Plan**: Detailed planning and architecture phase  
- **Design**: Technical design and specification phase
- **Implementation**: Active development phase
- **Testing**: Quality assurance and validation phase
- **Review**: Code review and refinement phase
- **Deployment**: Release and deployment phase
- **Completion**: Post-deployment and retrospective phase

### File Naming Convention (Version-First)
```
Format: {project-type}-{project-name}-v{major}.{minor}.{patch}.md

Examples:
- feature-user-auth-v1.0.0.md
- refactor-mcp-market-v2.1.0.md
- bugfix-login-flow-v1.0.1.md
- documentation-api-guide-v1.0.0.md
- audit-system-security-v1.0.0.md
- plan-enterprise-roadmap-v1.0.0.md
```

### Directory Structure (Version-Organized)
```
./docs/projects/
├── ideas/                    # Initial concepts
├── active/                   # Currently active projects
│   ├── v1/                   # Version 1 projects
│   ├── v2/                   # Version 2 projects
│   └── v3/                   # Version 3 projects
├── completed/                # Finished projects
│   ├── v1/                   # Completed v1 projects
│   ├── v2/                   # Completed v2 projects
│   └── v3/                   # Completed v3 projects
├── templates/                # Project templates
├── plans/                    # Plan analysis documents
└── versions/                 # Version tracking
    ├── v1.0.0/              # Version-specific docs
    ├── v1.1.0/
    └── v2.0.0/
```

## Project Document Management

### Document Structure Compliance
- All project documents must follow the template structure in `./docs/projects/templates/`
- Metadata section must be complete and current
- All required sections must be filled out before moving to active status

### Stage Transitions
- Only move projects from ideas to active when planning is complete
- Update stage field when advancing through lifecycle stages
- Document stage transitions in progress log

### Progress Tracking
- Add progress log entries after each work session
- Include files changed, stage updates, and key accomplishments
- Maintain chronological order in progress logs

### Decision Documentation
- Document all architectural and technical decisions
- Include rationale, alternatives considered, and impact assessment
- Record decision maker and date

### Blocker Management
- Update blockers section when issues arise
- Include priority, assignment, and impact information
- Mark blockers as resolved when addressed

### Handoff Protocol
- Complete current work before handoffs
- Document context for receiving agent
- Include completed work summary and next steps
- Add important warnings or considerations

## Validation Requirements

### Before Moving to Active
- All metadata fields completed
- Human context section filled out
- AI agent context section completed
- Initial tasks defined
- Dependencies identified

### During Development
- Progress log updated regularly
- Decisions documented as made
- Blockers tracked and updated
- File references maintained

### Before Completion
- All acceptance criteria met
- Lessons learned documented
- Cross-references updated
- Archive preparation complete

## Commit Integration Rules

### Regular Commit Requirements
- **Phase Commits**: Commit at the end of each project phase
- **Milestone Commits**: Commit when reaching project milestones
- **Feature Commits**: Commit when completing major features
- **Daily Commits**: Commit at least once per day when actively working

### Commit Message Format
```
{type}({project}): {description} [v{major}.{minor}.{patch}]

Examples:
feat(user-auth): implement JWT authentication [v1.0.0]
refactor(mcp-market): decompose monolithic component [v2.1.0]
docs(api): add comprehensive API documentation [v1.0.0]
fix(login): resolve password validation issue [v1.0.1]
audit(security): complete security assessment [v1.0.0]
plan(enterprise): create roadmap document [v1.0.0]
```

### Automated Commit Triggers
- **On Phase Completion**: Automatic commit with phase summary
- **On Milestone Reached**: Commit with milestone details
- **On Blocker Resolved**: Commit with resolution details
- **On Project Completion**: Final commit with retrospective

## Quick Commands

### Core Project Management
- `project new` - Start new project workflow
- `project status` - Show current project status
- `project continue` - Resume last active project
- `project complete` - Mark current project as complete
- `project version` - Show project version information
- `project plan` - Show project plan analysis

### Version Management
- `version bump` - Increment project version
- `version history` - Show version history
- `version compare` - Compare project versions
- `version rollback` - Rollback to previous version

### Commit Management
- `commit phase` - Commit current project phase
- `commit milestone` - Commit project milestone
- `commit daily` - Daily project commit
- `commit final` - Final project completion commit

### Plan Analysis
- `plan analyze` - Analyze project plan
- `plan validate` - Validate project plan
- `plan optimize` - Optimize project plan
- `plan track` - Track plan progress

## Status Reporting

### Enhanced Status Report Format
```
**Status Report**
- Project: {name} [v{major}.{minor}.{patch}]
- Stage: {current-stage}
- Phase: {current-phase}
- Files Changed: {count} files
- Tasks: {completed}/{total}
- Blockers: {count} active
- Commits: {count} this phase
- Next: {next-immediate-action}
- Version: {next-version}
```

### Metrics Tracking
- Task completion percentage
- Blocker count and priority
- Estimated vs actual time
- File change count
- Commit frequency
- Version progression
- Plan adherence percentage

## Quality Assurance

### Project Validation
- All projects must have complete metadata
- Version numbers must follow semantic versioning
- File names must follow version-first convention
- Progress logs must be updated regularly
- Commits must reference project versions

### Code Quality Integration
- All code changes must align with project goals
- Acceptance criteria must be validated
- Project constraints must be respected
- Architectural decisions must be documented
- Performance impact must be assessed

### Relative Path Compliance
- **MANDATORY**: All file references must use relative paths from project root
- **FORBIDDEN**: Absolute paths like `/Users/username/` or `C:\Users\`
- **REQUIRED**: Use `./` prefix for current directory references
- **ENFORCED**: All documentation must use relative paths
- **VALIDATED**: Path references must be portable across different environments
- **UTILITY**: Use `app/utils/path.ts` functions for consistent path handling

## Integration Points

### Codebase References
- **MANDATORY**: Use relative file paths in project documents
- **FORBIDDEN**: Absolute paths like `/Users/username/` or `C:\Users\`
- **REQUIRED**: Use `./` prefix for current directory references
- Reference existing documentation and code using relative paths
- Maintain alignment with codebase structure

### Cross-Project Dependencies
- Document dependencies between projects
- Update related projects when completing work
- Maintain dependency tracking

## Automation Integration

### Git Hooks
- Pre-commit: Validate project context
- Post-commit: Update project progress
- Pre-push: Validate project completeness
- Post-merge: Update project dependencies

### CI/CD Integration
- Build triggers on project phase completion
- Test execution on milestone commits
- Deployment triggers on version releases
- Rollback triggers on project failures

## Response Guidelines

### Minimal Responses
- Keep responses concise and focused
- Always include enhanced status report
- Use bullet points for clarity
- Reference project versions

### Auto-Suggestions
- Suggest project creation for significant changes
- Recommend version bumps for major changes
- Propose plan analysis for complex projects
- Suggest commit strategies for long-running work

### Context Preservation
- Maintain project context across conversations
- Reference project versions and phases
- Preserve decision history and rationale
- Track version progression and plan adherence

## Rule Compliance Validation

### Automatic Validation
- **File Naming**: Validate all project files follow version-first convention
- **Directory Structure**: Ensure projects are in correct version directories
- **Metadata Completeness**: Check all required metadata fields are present
- **Relative Paths**: Validate all file references use relative paths
- **Commit Messages**: Ensure commit messages reference project versions

### Manual Validation Checklist
- [ ] Project follows version-first naming convention
- [ ] Project is in correct version directory (v1/, v2/, v3/)
- [ ] All metadata fields are complete and current
- [ ] Progress log is updated with recent work
- [ ] All file references use relative paths
- [ ] Commit messages reference project versions
- [ ] Dependencies are documented and up-to-date
- [ ] Acceptance criteria are clearly defined
- [ ] Project constraints are respected
- [ ] Architectural decisions are documented